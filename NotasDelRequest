Pendiente de reconfirmar:

GETTERS Y SETTERS
.- El uso de setters y getters

	Los CGI no reciben todo el body en la primera petición, y esnecesario construirlo con la respuesta que desde el 
	mismo cgi se consigan del el objeto cgi que creemos


BODY_SIZE
.- Si el tamaño del body delimitado por las directivas de configuración afectan solo al content_lenght 
	o tambien al transfer-encoding =chunked

PATH
.- Si la comprobación del path tanto en las query como en los fragments es correcto para evitar
	ataques de "Directory Traversal" aceder a archivos por encima de la rais de la aplicación

URI_MAX_LENGTH
.- Reconfirmar como evaluar la medida Máxima de la URI 

	DE momento se evalua con i, que es el tamaño de la requisición hasta el final del, path, de la query y/o del fragment, 
	
	Según la rfc la URI la compone: 	 

	Esquema: (http://, https://)
	Host: El nombre de dominio o la dirección IP del servidor (www.ejemplo.com, 192.168.0.1)
	Puerto (si es diferente del predeterminado, como :8080)
	Ruta: La parte del camino después del dominio (/ruta/archivo)
	Query string: Parámetros pasados en la URL después de ? (?param1=valor1&param2=valor2)
	Fragmento: Parte de la URI después del # que generalmente no se envía al servidor (pero puede estar presente en la URI).

	Nosotros restringimos el esquema válido a http. y en request cuando la información del host está dentro de llos headers se guarda en _headers(host), incluyendo el puerto por lo edspués de gestionar los headers se podría calcular así:

	http://(7) + 
	host:puerto  que habría que calcular con el tamaño de la cadena devuelta por(getHeader(host)) + _path.size() +
	_query.size() + 
	_fragment.size(); 

	La cuestión es ver donde calcularlo, si merece la pena ser tan preciso y/o si podríamos sacar los valores del host y el puerto desde el archivo de confirguarción, del server o del cliente y pasarlo como parámetro o ver la manera de separar en funciones la lectura de la primera línea al completo, evaluar el valor desde el punto en el que se hace la llamada a esa función, guardando el resto de la petición y si todo es correcto continuar con el parseo del resto de la petición.

HOST
	El header host almacenta tanto el propio host como el puerto (host:puerto) y asigna el valor propio del host a la variable _serverName, ver si es correcto o es mejor separarlo.

PUNTERO A CLIENTE
	sería interesante generar el request con un puntero al cliente para poder acecder a todos los datos	